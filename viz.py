# -*- coding: utf-8 -*-
"""viz.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1PSlxNfr6fduORCDa2D3nU-FmgMQ7sk14
"""

!pip install opendatasets
!pip install nibabel
!pip install pydicom

import os
import nibabel as nib
import matplotlib.pyplot as plt
import numpy as np
import pydicom

import opendatasets as od
od.download("https://www.kaggle.com/datasets/andrewmvd/liver-tumor-segmentation")

od.download("https://www.kaggle.com/datasets/tawsifurrahman/tuberculosis-tb-chest-xray-dataset")

# now we do windowing overlay images
import nibabel as nib
import numpy as np
import matplotlib.pyplot as plt
#Reads the .nii file from disk.
#Returns a 3D NumPy array (CT or mask volume).
#Example: shape (512, 512, 100) = 100 slices of 512×512.
def load_nifti(path):
    """Load NIfTI file and return numpy array"""
    return nib.load(path).get_fdata()
    """
    Apply windowing to a CT image.
    img: CT scan slice
    window_center: center value (e.g. 40 for soft tissue)
    window_width: width (e.g. 400)
    """
def window_image(img, window_center, window_width):

    img_min = window_center - (window_width / 2)
    img_max = window_center + (window_width / 2)
    windowed_img = np.clip(img, img_min, img_max)
    return (windowed_img - img_min) / (img_max - img_min)

# Example usage:
ct_path = "/content/liver-tumor-segmentation/volume_pt1/volume-0.nii"
mask_path = "/content/liver-tumor-segmentation/segmentations/segmentation-0.nii"

ct_volume = load_nifti(ct_path)
mask_volume = load_nifti(mask_path)

# Pick one slice (z = 40)
#Takes the 40th axial slice (cross-section).
#ct_slice → 2D CT scan.
#mask_slice → binary mask of tumor in same slice.
z = 40
ct_slice = ct_volume[:, :, z]
mask_slice = mask_volume[:, :, z]

# Apply windowing (soft tissue ~ center=40, width=400)
windowed_slice = window_image(ct_slice, 40, 400)

# Show with tumor overlay
plt.figure(figsize=(10,5))
plt.imshow(windowed_slice, cmap="gray")
plt.imshow(mask_slice, cmap="Reds", alpha=0.3)
plt.title(f"CT Slice {z} with Tumor Overlay")
plt.axis("off")
plt.show()

import nibabel as nib
import numpy as np
import matplotlib.pyplot as plt

def load_nifti(path):
    """Load NIfTI file and return numpy array"""
    return nib.load(path).get_fdata()

def window_image(img, window_center, window_width):

#Apply windowing to a CT image.
#img: CT scan slice
#window_center: center value (e.g. 40 for soft tissue)
#window_width: width (e.g. 400)

    img_min = window_center - (window_width / 2)
    img_max = window_center + (window_width / 2)
    windowed_img = np.clip(img, img_min, img_max)
    return (windowed_img - img_min) / (img_max - img_min)

# Example usage:
ct_path = "/content/liver-tumor-segmentation/volume_pt1/volume-0.nii"
mask_path = "/content/liver-tumor-segmentation/segmentations/segmentation-0.nii"


ct_volume = load_nifti(ct_path)
mask_volume = load_nifti(mask_path)

# Pick one slice (z = 40)
z = 40
ct_slice = ct_volume[:, :, z]
mask_slice = mask_volume[:, :, z]

# Apply windowing (soft tissue ~ center=40, width=400)
windowed_slice = window_image(ct_slice, 40, 400)

# Find tumor region (non-zero pixels in mask)
#Finds all pixel coordinates where mask > 0 (tumor present).
#Computes bounding box:
#(x_min, y_min) → top-left
#(x_max, y_max) → bottom-right
#If no tumor found, bounding box = zeros.
coords = np.argwhere(mask_slice > 0)
if coords.size > 0:
    y_min, x_min = coords.min(axis=0)
    y_max, x_max = coords.max(axis=0)
else:
    y_min, x_min, y_max, x_max = [0, 0, 0, 0]

# Show with tumor overlay
plt.figure(figsize=(8, 8))
plt.imshow(windowed_slice, cmap="gray")
plt.imshow(np.ma.masked_where(mask_slice == 0, mask_slice), cmap="Reds", alpha=0.4)

# Draw bounding box if tumor is present
if coords.size > 0:
    rect = plt.Rectangle((x_min, y_min), x_max - x_min, y_max - y_min,
                         linewidth=2, edgecolor="red", facecolor="none")
    plt.gca().add_patch(rect)

plt.title(f"CT Slice {z} with Tumor Overlay + Bounding Box")
plt.axis("off")
plt.show()

# all slices are present in the dicom/nifti form images
import nibabel as nib
import numpy as np
import matplotlib.pyplot as plt

# Paths
ct_path = "/content/liver-tumor-segmentation/volume_pt1/volume-1.nii"
mask_path = "/content/liver-tumor-segmentation/segmentations/segmentation-1.nii"

# Load data
ct_volume = nib.load(ct_path).get_fdata()
mask_volume = nib.load(mask_path).get_fdata()

# Windowing function
def window_image(img, window_center=40, window_width=800):
    img_min = window_center - (window_width / 2)
    img_max = window_center + (window_width / 2)
    windowed_img = np.clip(img, img_min, img_max)
    return (windowed_img - img_min) / (img_max - img_min)

# Show ALL slices
num_slices = ct_volume.shape[2]
for z in range(num_slices):
    ct_slice = ct_volume[:, :, z]
    mask_slice = mask_volume[:, :, z]

    windowed_slice = window_image(ct_slice)

    plt.figure(figsize=(5, 5))
    plt.imshow(windowed_slice, cmap="gray")
    plt.imshow(mask_slice, cmap="Reds", alpha=0.3)
    plt.title(f"Slice {z}/{num_slices-1}")
    plt.axis("off")
    plt.show()

#Windowing presets
#These are predefined center (WC) and width (WW) values for different tissue types.
#liver → soft tissue window, which is what we mostly use.
#Later in the function, you can override WC/WW if you want custom windowing.
WINDOW_PRESETS = {
    "liver":  (40, 400),     # soft tissue
    "lung":   (-600, 1500),
    "bone":   (400, 1800),
}

#Apply a windowing preset OR custom wc/ww to a 2D slice.
#If wc/ww are provided, they override the preset.
def apply_preset(slice2d: np.ndarray, preset: str = "liver", wc: float = None, ww: float = None):

    if wc is None or ww is None:
        if preset not in WINDOW_PRESETS:
            raise ValueError(f"Unknown preset '{preset}'. Choose from {list(WINDOW_PRESETS.keys())}")
        wc, ww = WINDOW_PRESETS[preset]
    return window_image(slice2d, wc, ww)


#Multi-plane slicing helpers
#Finds the center slice index along the given plane if no slice index is provided.
#Axial = z-axis, Coronal = y-axis, Sagittal = x-axis.
def _center_index_for_plane(volume: np.ndarray, plane: str) -> int:
    if plane == "axial":    # z
        return volume.shape[2] // 2
    if plane == "coronal":  # y
        return volume.shape[1] // 2
    if plane == "sagittal": # x
        return volume.shape[0] // 2
    raise ValueError("plane must be 'axial', 'coronal', or 'sagittal'")


#Return a 2D slice from a 3D volume in the requested plane.
#Returned slice is transposed with origin='lower' orientation for consistent display.
def get_slice(volume: np.ndarray, index: int = None, plane: str = "axial") -> np.ndarray:

    if plane not in {"axial", "coronal", "sagittal"}:
        raise ValueError("plane must be 'axial', 'coronal', or 'sagittal'")

    if index is None:
        index = _center_index_for_plane(volume, plane)

    if plane == "axial":      # z
        if not (0 <= index < volume.shape[2]):
            raise IndexError(f"index out of range for axial plane: 0..{volume.shape[2]-1}")
        sl = volume[:, :, index]
    elif plane == "coronal":  # y
        if not (0 <= index < volume.shape[1]):
            raise IndexError(f"index out of range for coronal plane: 0..{volume.shape[1]-1}")
        sl = volume[:, index, :]
    else:                     # sagittal (x)
        if not (0 <= index < volume.shape[0]):
            raise IndexError(f"index out of range for sagittal plane: 0..{volume.shape[0]-1}")
        sl = volume[index, :, :]

    return sl.T
# for consistent orientation in imshow(origin="lower")
#Plotting with presets and overlays
#Displays a single CT slice with windowing applied.
#Can use preset or custom windowing.
#Automatically sets axis off and origin='lower' for consistent visualization.
def show_slice(
    ct_volume: np.ndarray,
    index: int = None,
    plane: str = "axial",
    preset: str = "liver",
    wc: float = None,
    ww: float = None,
    title: str = None,
):
#Show a windowed CT slice in any plane using a preset or custom wc/ww.

    sl = get_slice(ct_volume, index, plane)
    wsl = apply_preset(sl, preset=preset, wc=wc, ww=ww)

    plt.figure(figsize=(6, 6))
    plt.imshow(wsl, cmap="gray", origin="lower")
    plt.title(title or f"{plane.capitalize()} slice {index if index is not None else '(center)'}  |  preset={preset}")
    plt.axis("off")
    plt.show()
#Shows CT slice with a mask overlay (tumor, segmentation, or prediction).
#alpha controls transparency of mask overlay.
#mask_threshold ensures mask is binary.

def show_overlay(
    ct_volume: np.ndarray,
    mask_volume: np.ndarray,
    index: int = None,
    plane: str = "axial",
    preset: str = "liver",
    wc: float = None,
    ww: float = None,
    alpha: float = 0.3,
    mask_threshold: float = 0.5,
    title: str = None,
):

#Show CT slice with a single mask overlay (e.g., predicted/GT).
#Shows CT slice with a mask overlay (tumor, segmentation, or prediction).
#alpha controls transparency of mask overlay.
#mask_threshold ensures mask is binary.

    img = get_slice(ct_volume, index, plane)
    wimg = apply_preset(img, preset=preset, wc=wc, ww=ww)
    msk = get_slice(mask_volume, index, plane) > mask_threshold

    plt.figure(figsize=(6, 6))
    plt.imshow(wimg, cmap="gray", origin="lower")
    plt.imshow(msk, cmap="Reds", alpha=alpha, origin="lower")
    plt.title(title or f"{plane.capitalize()} slice {index if index is not None else '(center)'}  |  {preset} window")
    plt.axis("off")
    plt.show()
#Displays side-by-side comparison:
#Left: Ground Truth (green)
#Right: Prediction (red)
#Useful for evaluating segmentation quality.
#Automatically applies windowing preset.

def compare_gt_pred(
    ct_volume: np.ndarray,
    gt_volume: np.ndarray,
    pred_volume: np.ndarray,
    index: int = None,
    plane: str = "axial",
    preset: str = "liver",
    wc: float = None,
    ww: float = None,
    alpha: float = 0.3,
    threshold: float = 0.5,
):

#Side-by-side: GT (green) vs Prediction (red) overlays on the same CT slice.

    img = get_slice(ct_volume, index, plane)
    wimg = apply_preset(img, preset=preset, wc=wc, ww=ww)
    gt  = (get_slice(gt_volume, index, plane)   > threshold)
    prd = (get_slice(pred_volume, index, plane) > threshold)

    fig, ax = plt.subplots(1, 2, figsize=(12, 6))

    ax[0].imshow(wimg, cmap="gray", origin="lower")
    ax[0].imshow(gt, cmap="Greens", alpha=alpha, origin="lower")
    ax[0].set_title(f"Ground Truth  |  {plane.capitalize()} {index if index is not None else '(center)'}")
    ax[0].axis("off")

    ax[1].imshow(wimg, cmap="gray", origin="lower")
    ax[1].imshow(prd, cmap="Reds", alpha=alpha, origin="lower")
    ax[1].set_title(f"Prediction  |  {plane.capitalize()} {index if index is not None else '(center)'}")
    ax[1].axis("off")

    plt.tight_layout()
    plt.show()

# axial @ z=40, soft-tissue window
show_slice(ct_volume, index=40, plane="axial", preset="liver")

# overlay GT mask on the same slice
show_overlay(ct_volume, mask_volume, index=40, plane="axial", preset="liver", alpha=0.3)

# compare GT vs a dummy pred (use mask_volume as placeholder now)
compare_gt_pred(ct_volume, gt_volume=mask_volume, pred_volume=mask_volume, index=40, plane="axial", preset="liver")

import nibabel as nib
import numpy as np
import matplotlib.pyplot as plt
from skimage.measure import label, regionprops
from skimage import exposure

# Utility Functions

def load_nifti(path):
    return nib.load(path).get_fdata()

def auto_window_image(img, percentile_low=0.5, percentile_high=99.5):
    """Auto windowing (percentile-based)"""
    low = np.percentile(img, percentile_low)
    high = np.percentile(img, percentile_high)
    img = np.clip(img, low, high)
    return (img - low) / (high - low + 1e-12)

def enhance_contrast(img):
    """Optional: Local contrast enhancement"""
    return exposure.equalize_adapthist(img, clip_limit=0.03)

# Paths

ct_path = "/content/liver-tumor-segmentation/volume_pt1/volume-1.nii"
mask_path = "/content/liver-tumor-segmentation/segmentations/segmentation-1.nii"

# Load

ct_vol = load_nifti(ct_path)
mask_vol = load_nifti(mask_path)

print("CT volume shape:", ct_vol.shape, "Mask volume shape:", mask_vol.shape)

# Montage Parameters

step = 10       # show every 10th slice
slices = range(0, ct_vol.shape[2], step)   # axial slices

ncols = 5
nrows = int(np.ceil(len(slices)/ncols))

fig, axes = plt.subplots(nrows, ncols, figsize=(15, 3*nrows))

for ax, z in zip(axes.flat, slices):
    ct_slice = ct_vol[:, :, z]
    mask_slice = mask_vol[:, :, z]
    mask_bin = (mask_slice > 0.5).astype(np.uint8)

    # windowing + contrast
    win = auto_window_image(ct_slice)
    win = enhance_contrast(win)

    ax.imshow(win, cmap="gray", origin="upper")
    ax.imshow(np.ma.masked_where(mask_bin == 0, mask_bin), cmap="Reds", alpha=0.35, origin="upper")

    # bounding boxes
    labels = label(mask_bin)
    for region in regionprops(labels):
        minr, minc, maxr, maxc = region.bbox
        rect = plt.Rectangle((minc, minr), maxc-minc, maxr-minr,
                             edgecolor="red", facecolor="none", linewidth=1.5)
        ax.add_patch(rect)

    ax.set_title(f"Slice {z}")
    ax.axis("off")

# Hide unused subplots if any
for ax in axes.flat[len(slices):]:
    ax.axis("off")

plt.tight_layout()
plt.show()

import nibabel as nib
import numpy as np
import matplotlib.pyplot as plt
from skimage.measure import label, regionprops
from skimage import exposure

# Utility Functions

def load_nifti(path):
    return nib.load(path).get_fdata()
#Auto-windowing: scales image intensity using percentiles → avoids very dark/bright slices.
#Enhance contrast: improves visibility using CLAHE (local contrast enhancement).
def auto_window_image(img, percentile_low=0.5, percentile_high=99.5):
    """Auto windowing (percentile-based)"""
    low = np.percentile(img, percentile_low)
    high = np.percentile(img, percentile_high)
    img = np.clip(img, low, high)
    return (img - low) / (high - low + 1e-12)

def enhance_contrast(img):
    """Optional: Local contrast enhancement"""
    return exposure.equalize_adapthist(img, clip_limit=0.03)

# Paths

ct_path = "/content/liver-tumor-segmentation/volume_pt1/volume-1.nii"
mask_path = "/content/liver-tumor-segmentation/segmentations/segmentation-1.nii"

# Load

ct_vol = load_nifti(ct_path)
mask_vol = load_nifti(mask_path)

print("CT volume shape:", ct_vol.shape, "Mask volume shape:", mask_vol.shape)

# Montage Parameters
#Picks every 10th axial slice to show a representative montage.
#Defines grid layout: 5 columns, rows computed automatically.

step = 1       # show every slice
slices = range(0, ct_vol.shape[2], step)

ncols = 8   # number of columns (adjust for readability)
nrows = int(np.ceil(len(slices)/ncols))

fig, axes = plt.subplots(nrows, ncols, figsize=(2*ncols, 2*nrows))

for ax, z in zip(axes.flat, slices):
    ct_slice = ct_vol[:, :, z]
    mask_slice = mask_vol[:, :, z]
    mask_bin = (mask_slice > 0.5).astype(np.uint8)

    # windowing + contrast
    win = auto_window_image(ct_slice)
    win = enhance_contrast(win)

    ax.imshow(win, cmap="gray", origin="upper")
    ax.imshow(np.ma.masked_where(mask_bin == 0, mask_bin), cmap="Reds", alpha=0.35, origin="upper")

#bounding boxes
#Detects connected tumor regions.
#Draws red rectangles around each tumor.
    labels = label(mask_bin)
    for region in regionprops(labels):
        minr, minc, maxr, maxc = region.bbox
        rect = plt.Rectangle((minc, minr), maxc-minc, maxr-minr,
                             edgecolor="red", facecolor="none", linewidth=1.2)
        ax.add_patch(rect)

    ax.set_title(f"Slice {z}", fontsize=8)
    ax.axis("off")

# Hide unused subplots if any
for ax in axes.flat[len(slices):]:
    ax.axis("off")

plt.tight_layout()
plt.show()

import matplotlib.pyplot as plt
import matplotlib.image as mpimg

# Path to the PNG image
img_path = "/content/tuberculosis-tb-chest-xray-dataset/TB_Chest_Radiography_Database/Normal/Normal-1.png"

# Load image
img = mpimg.imread(img_path)

# Display
plt.figure(figsize=(6,6))
plt.imshow(img, cmap="gray")   # grayscale X-ray
plt.title("Chest X-ray: Normal")
plt.axis("off")
plt.show()

od.download("https://www.kaggle.com/datasets/modaresimr/medical-image-segmentation")