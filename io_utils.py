# -*- coding: utf-8 -*-
"""io_utils.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1VVCltVrXIv3vyimi2yRcpSC049pYDUtp
"""

!pip install opendatasets

import opendatasets as od
od.download("https://www.kaggle.com/datasets/andrewmvd/liver-tumor-segmentation")
od.download("https://www.kaggle.com/datasets/tawsifurrahman/tuberculosis-tb-chest-xray-dataset")

!pip install nibabel

!pip install pydicom

#import important library
import os# Operarting system interface,, it is a inbuild function in python that help to intract with the file system and OS commands
import numpy as np
import nibabel as nib# It is a inbuild python library that is specially design for medical images like dicom/nifti and many others
import pydicom
from pydicom.uid import generate_uid #UID unique identifier that means it create a unique id for each dicom file so that they not collab with eaach other
from PIL import Image #PIL = Python Imaging Library (used for opening, editing, and saving images).
from glob import glob # It’s used to find file paths matching a pattern.

"""
  DICOM

DICOM is a clinical standard (used in hospitals).
Every image/slice must have a UID so that it can be uniquely identified in hospital systems (PACS).
That’s why we use generate_uid() → to avoid collisions and keep track of studies, series, and slices.

  NIfTI

NIfTI is mostly used in research & AI projects.
It’s one single file (often .nii or .nii.gz) that contains the whole 3D/4D scan.
It doesn’t need UIDs because:
All slices are stored together in one volume.
There’s no hospital PACS system managing them.
Researchers just care about the matrix of voxels + metadata (spacing, affine transform).
"""

#code for load nifti file from system
def load_nifti(file_path):
    nii = nib.load(file_path)
    volume = nii.get_fdata() #volume is a NumPy array with shape like (512, 512, 122)
    header = nii.header #Gets the header information from the NIfTI file. like voxel spacing, data type, orientation, etc.
    spacing = header.get_zooms() # (x, y, z) in mm
    return volume, spacing

#code for load dicom file from system
def load_dicom(folder_path):

    dicom_files = sorted(glob(os.path.join(folder_path, "*.dcm")))
# Finds all files with .dcm extension in the given folder.
#Sorts them by filename (temporary sorting, real sorting is done later by slice position).
# Example: if folder has 100 CT slices, this collects them.

    if not dicom_files:
        raise FileNotFoundError(f"No DICOM files found in {folder_path}")
#If no DICOM files are found, it throws an error.

    slices = [pydicom.dcmread(f) for f in dicom_files]
#Uses pydicom to read each file into a Dataset object (which contains metadata + pixel data).
    slices.sort(key=lambda x: float(x.ImagePositionPatient[2]))  # sort by z-axis
#CT/MRI slices can be shuffled.
#ImagePositionPatient[2] → gives the z-axis position of each slice in the patient’s body.
#Sorting ensures slices are arranged head-to-toe or toe-to-head properly.
# Pixel array to volume
    volume = np.stack([s.pixel_array for s in slices], axis=-1)
#s.pixel_array extracts the actual image pixels from each DICOM.
#np.stack(..., axis=-1) stacks them along the last dimension.
#Result = a 3D NumPy array (height × width × number_of_slices).
#Basically, it builds the "3D cube" of the scan.

    # Extract spacing
    px_spacing = slices[0].PixelSpacing  # (row, col) -> (y, x)
    slice_thickness = getattr(slices[0], "SliceThickness", 1.0)
    spacing = (float(px_spacing[0]), float(px_spacing[1]), float(slice_thickness))  # (y, x, z)
#PixelSpacing = how big each pixel is in real-world units (mm).
#Usually something like [0.7, 0.7] mm (y, x).
#SliceThickness = distance between slices in z-direction.
#Together they give you (y_spacing, x_spacing, z_spacing) → voxel spacing in mm.

    return volume, spacing

#Load png file
\
def load_png(filepath):
    """Load a PNG (2D) image and return as fake 3D volume"""
    img = Image.open(filepath).convert("L")
# grayscale
#Uses PIL (Pillow) to open the image.
#.convert("L") → converts it to grayscale (single channel, values 0–255).
#Because medical images are usually grayscale, not RGB.
    data = np.array(img)
#Turns the grayscale image into a NumPy array.
#Shape will be (height, width).
#Make it 3D with depth=1 (so it matches NIfTI/DICOM shape convention)
    volume = data[:, :, np.newaxis]
#Adds a new axis at the end.
#Shape becomes (height, width, 1) instead of (height, width).
#That way, it mimics a 3D medical scan with just one slice of depth.
#Example: CT/MRI is usually (H, W, N_slices) → this PNG is treated like (H, W, 1).

    # PNG has no voxel spacing, so just return (1,1,1) as dummy spacing
    spacing = (1.0, 1.0, 1.0)
#Real medical images (DICOM/NIfTI) have voxel spacing in mm.
#PNG doesn’t store that info.
#So the function just returns fake spacing = (1,1,1) (unit spacing).
    return volume, spacing

def load_volume(filepath_or_folder):

    if os.path.isfile(filepath_or_folder):
#If the path points to a single file (like scan.nii.gz or xray.png).
        if filepath_or_folder.endswith((".nii", ".nii.gz")):
            return load_nifti(filepath_or_folder)
#If the file ends with .nii or .nii.gz, call the NIfTI loader.
#Example: MRI volumes often come as .nii.gz.
        elif filepath_or_folder.endswith((".png", ".jpg", ".jpeg", ".bmp", ".tiff")):
            return load_png(filepath_or_folder)
#If the file is a normal image format, call load_png() (which wraps it as fake 3D volume).
        else:
            raise ValueError("Unsupported file type. Use .nii/.nii.gz, .png, or .jpg.")
#If it’s some unknown file type (like .txt), it throws an error.
    elif os.path.isdir(filepath_or_folder):
        return load_dicom(filepath_or_folder)
#If the path is a directory, it assumes the folder contains DICOM files.
#Calls load_dicom() to load all slices.
    else:
        raise FileNotFoundError(f"Path not found: {filepath_or_folder}")
#If the path is neither a file nor a folder → raises an error.

!pip install io_utils# it is a inbuild function that is use the code  neat and clean ,, Instead of writing load_dicom, load_png, load_nifti, etc. in every script, you just keep them in one place.

#Extract data
#io_utils.py for load NFTI/DICOM return volume+spacing
# Example NIfTI scan

volume, spacing = load_volume("liver-tumor-segmentation/segmentations/segmentation-0.nii")

print("Volume shape:", volume.shape)
print("Voxel spacing (mm):", spacing)

volume, spacing = load_volume("/content/tuberculosis-tb-chest-xray-dataset/TB_Chest_Radiography_Database/Normal/Normal-10.png")

print("Volume shape:", volume.shape)
print("Voxel spacing (mm):", spacing)

